{"name":"Goroutes","tagline":"A routing library for go with RESTful url routing to controllers","body":"Goroutes\r\n=========\r\n\r\nAbout\r\n-----\r\nGoroutes is a url routing library for go with support for routing RESTful routes to controllers.\r\n\r\nThis started a with me wanting to experiment with go, but i have been developing using rails for the past months and a quickly missed a lot of its features. Url routing with variables and RESTful routes to controllers were one of the major features i missed so i decided to build this RESTful routing library for go.\r\n\r\nIt takes inspiration from rails as well as the standard go url routing found in net/http.\r\n\r\n\r\nGetting started\r\n---------------\r\nFirst thing you have to do is get the project\r\n```shell\r\ngo get github.com/emilsjolander/goroutes\r\n```\r\n\r\nAfter that all you need to do is import it into your project\r\n```go\r\nimport \"github.com/emilsjolander/goroutes\"\r\n```\r\n\r\nDone! Now just match some routes and press Start!\r\nThe server will run on port 9999. Test it out locally at http://localhost:9999/\r\n```go\r\ngoroutes.Resources(new(UsersController))\r\ngoroutes.Resources(new(NotesController), \"UsersController\")\r\n\r\ngoroutes.MatchFunc(\"GET\", \"/status\", \r\n  func(w http.ResponseWriter, req *http.Request){\r\n    fmt.Fprintf(w, \"Status ok!\")\r\n  })\r\n\r\ngoroutes.Match(\"GET\", \"/assets/*\", http.StripPrefix(\"/assets/\", http.FileServer(http.Dir(\"assets\"))))\r\ngoroutes.Match(\"GET\", \"/\", new(HomeHandler))\r\n\r\ngoroutes.Start()\r\n```\r\n\r\n\r\nApi\r\n---\r\nI have designed the api to be as similar as possible to go's routing while at the same time adding as many of the great routing features that come with a framework like rails.\r\n\r\n###Controllers\r\nThis is the Controller interface. If your datastructure implements this interface goroutes can match RESTful routes the the corrosponding methods.\r\n```go\r\ntype Controller interface {\r\n  Index   (w http.ResponseWriter, req *http.Request)\r\n  New     (w http.ResponseWriter, req *http.Request)\r\n  Create  (w http.ResponseWriter, req *http.Request)\r\n  Show    (w http.ResponseWriter, req *http.Request)\r\n  Edit    (w http.ResponseWriter, req *http.Request)\r\n  Update  (w http.ResponseWriter, req *http.Request)\r\n  Destroy (w http.ResponseWriter, req *http.Request)\r\n}\r\n```\r\n\r\nA lot of times a controller will only want to implement a handful of these methods, for this i have defined a BaseController struct that can be included into any controller as an anonymous field. Any method not overriden in your struct will answer the request with a 404.\r\n```go\r\ntype MyController struct {\r\n    goroutes.BaseController\r\n}\r\n\r\nfunc (c *MyController) Index(w http.ResponseWriter, req *http.Request) {\r\n    // my response\r\n}\r\n```\r\n\r\nTo generate resources for a controller call\r\n```go\r\ngoroutes.Resources(new(ExampleController))\r\n```\r\nThis call will generate the following resources\r\n```text\r\nGET      /example             (Index)    \r\nGET      /example/new         (New)\r\nPOST     /example             (Create)\r\nGET      /example/:Id         (Show)\r\nGET      /example/:Id/edit    (Edit)\r\nPUT      /example/:Id         (Update)\r\nDELETE   /example/:Id         (Destroy)\r\n```\r\n\r\nIf any number of parent controllers were given that would prefix every url pattern with /parents/:ParentId, this can be achieved by the following method call.\r\n```go\r\ngoroutes.Resources(new(ExampleController), \"ParentsController\")\r\n```\r\n\r\nMultiple parent controllers are also supported\r\n```go\r\ngoroutes.Resources(new(ExampleController), \"ParentsController\", \"GrandparentsController\")\r\n```\r\n\r\nThe preceding call would generate the following resources.\r\n```text\r\nGET      /grandparents/:GrandparentId/parents/:ParentId/example             (Index)    \r\nGET      /grandparents/:GrandparentId/parents/:ParentId/example/new         (New)\r\nPOST     /grandparents/:GrandparentId/parents/:ParentId/example             (Create)\r\nGET      /grandparents/:GrandparentId/parents/:ParentId/example/:Id         (Show)\r\nGET      /grandparents/:GrandparentId/parents/:ParentId/example/:Id/edit    (Edit)\r\nPUT      /grandparents/:GrandparentId/parents/:ParentId/example/:Id         (Update)\r\nDELETE   /grandparents/:GrandparentId/parents/:ParentId/example/:Id         (Destroy)\r\n``` \r\n\r\n###Controller naming\r\nA Controller's name must end with 'Controller' e.g. `UsersController`, `InfoController` and so on. A controller with a plural name such as `UsersController` will have it's id parameter singularized when accessed via a child controller, a child controller of `UsersController` would look for a `UserId` param that is. Controller names made up of multiple words such as `SuperUserController` will become `/super_user` in the url.\r\n\r\n###Before filter\r\nOften time you will want to do a certain thing for many, if not all the actions in a controller. One example of this would be authentication. To make sure you do not repeat yourself your controller should implement the BeforeFilterer interface. In the BeforeFilter method you can deal will everything that you would otherwise repeat in many action methods. Save any data in the controller struct fields so they can be accessed from the action method which is called after.\r\n```go\r\ntype BeforeFilterer interface{\r\n  BeforeFilter(a Action, w http.ResponseWriter, r *http.Request) bool\r\n}\r\n```\r\nThis method will be called just before the action method is called. Returning false from this method will result if the action method not being called, returning true will call the action method directly after the before filter. The action sent to this method is one of the following defined in controller.go.\r\n```go\r\ntype Action uint\r\nconst (\r\n  Index Action = iota\r\n  New\r\n  Create\r\n  Show\r\n  Edit\r\n  Update\r\n  Destroy\r\n)\r\n```\r\n\r\n###Single function routing\r\nControllers are not always the correct solution so there are two more methods for routing urls.\r\nThey are really the same method only one takes in a struct implementing http.Handler and the other a handler function.\r\n```go\r\nfunc Match(method string, pattern string, handler http.Handler) error\r\nfunc MatchFunc(method string, pattern string, handler func(http.ResponseWriter, *http.Request)) error \r\n```\r\n\r\nThey expect a http method (GET, POST, PUT or DELETE) or a empty string to indicate that the handler will handle all methods.\r\nThe pattern sent in can contain variables which are preceded with a ':'. The last segment or the url may also be the wildcard character '*'. The wilcard will match anything after it while the variables will only match anything in the corresponding segment.\r\n\r\n\r\n###Extracting url values\r\nPattern variables are extracted from the Request the same way form and query params are extracted.\r\n```go\r\nfunc (c *ExampleController) Show(w http.ResponseWriter, req *http.Request) {\r\n  req.ParseForm()\r\n  id := req.Form[\"Id\"][0]\r\n  parentId := req.Form[\"ParentId\"][0]\r\n}\r\n```\r\nRemember that if the controllers parent name is plural, the id name will be singular.\r\n\r\n\r\n###Namespaces\r\nGoroutes makes it easy to namespace your resources. You can wrap any of the above function calls in a call to the Namespace function.\r\n```go\r\nfunc Namespace(ns string, f func())\r\n```\r\n`ns` is the namespace you want to route inside and `f` is the function where all route matching for this namespace should occur.\r\nCalls to the Namespace function can be nested. Here is an example of this.\r\n```go\r\ngoroutes.Namespace(\"api\", func(){\r\n  goroutes.Match(\"GET\", \"/info\", infoHandler)\r\n  goroutes.Namespace(\"v1\", func(){\r\n    goroutes.Match(\"GET\", \"/login\", loginHandler)\r\n  })\r\n})\r\n```\r\nThe above code generates the following routes.\r\n```text\r\nGET   /api/info\r\nGET   /api/v1/login\r\n```\r\n\r\n\r\nLimitations\r\n-----------\r\nCurrently goroutes is not thread safe during the initialization process. This means that until this limitation is fixed you should do all setup in a single goroutine, the main function is a very good place for this.\r\n\r\n\r\nContributing\r\n------------\r\nPull requests and issues are very welcome!\r\n\r\nFeature request are also welcome but i can't make any promise that they will make it in.\r\nI would like to keep the library as general as possible, if you are unsure you can just ask before you code ;)\r\n\r\n\r\nLicense\r\n-------\r\n\r\n    Copyright 2013 Emil Sj√∂lander\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}